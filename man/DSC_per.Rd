% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DSC_per.R
\name{DSC_per}
\alias{DSC_per}
\title{Permutation}
\usage{
DSC_per(
  c_df,
  t_df,
  T0,
  M = 100,
  solver = "SCS",
  ww = 0,
  peridx = 0,
  evgrid = seq(from = 0, to = 1, length.out = 101),
  graph = TRUE,
  y_name = "y",
  x_name = "x"
)
}
\arguments{
\item{c_df}{a list of list: each sublist contains observations of every control units at a specific time period.
e.g. \code{c_df[[1]][[2]]} contains the observations of the second control unit at the first time period.}

\item{t_df}{a list of observations. e.g. \code{t_df[[1]]} contains the observations of the target at the first time period.}

\item{T0}{an integer specifying the end of pre-treatment period.}

\item{M}{an integer specifying the number of draws from the uniform distribution for approximating the integral.}

\item{solver}{a solver for the optimization problem; see \code{\link[CVXR]{installed_solvers}} in CVXR for more options.}

\item{ww}{0 or a vector. By default, i.e. 0, arithmetic mean is used for calculating optimal weights.
Otherwise, a vector of specific weights is used.}

\item{peridx}{0 or a vector. By default, i.e. 0, all control units will be used for the permutation.
Otherwise, a vector of specific control units will be used.}

\item{evgrid}{a vector of gridpoints used to evaluate quantile functions.}

\item{graph}{\code{TRUE/FALSE}, indicating whether to output a plot of squared Wasserstein distances.}

\item{y_name}{a string for the title of the y-axis.}

\item{x_name}{a string for the title of the x-axis.}
}
\value{
\code{DSC_per} returns a list containing the following components:
\item{\code{target.dist}}{a vector of squared Wasserstein distances calculated using original target and control units.}
\item{\code{control.dist}}{a list of squared Wasserstein distances calculated using permutation distributions.}
}
\description{
Function for evaluating the significance of the estimates using permutation distributions
}
\examples{
#simulated data from independent normal distributions
#ex_normal() calls the simulated data
#detail can be found by ??ex_normal
#all control units are used
DSC_per(c_df=ex_normal()$control, t_df=ex_normal()$target, T0=5, M=100, solver="SCS", ww=0, peridx=0, evgrid=seq(from=0, to=1, length.out=1001), graph=TRUE, y_name='y', x_name='x')
#the first, third and fifth control units are used
DSC_per(c_df=ex_normal()$control, t_df=ex_normal()$target, T0=5, M=100, solver="SCS", ww=0, peridx=c(1,3,5), evgrid=seq(from=0, to=1, length.out=1001), graph=TRUE, y_name='y', x_name='x')
}
