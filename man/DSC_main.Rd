% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DSC_main.R
\name{DSC_main}
\alias{DSC_main}
\title{Main Ouputs of DSC}
\usage{
DSC_main(
  c_df,
  t_df,
  T0,
  M = 100,
  solver = "SCS",
  ww = 0,
  evgrid = seq(from = 0, to = 1, length.out = 101),
  cl = 0.99,
  num.redraws = 500
)
}
\arguments{
\item{c_df}{a list of list: each sublist contains observations of every control units at a specific time period.
e.g. \code{c_df[[1]][[2]]} contains the observations of the second control unit at the first time period.}

\item{t_df}{a list of observations. e.g. \code{t_df[[1]]} contains the observations of the target at the first time period.}

\item{T0}{an integer specifying the end of pre-treatment period.}

\item{M}{an integer specifying the number of draws from the uniform distribution for approximating the integral.}

\item{solver}{a solver for the optimization problem; see \code{\link[CVXR]{installed_solvers}} in CVXR for more options.}

\item{ww}{0 or a vector. By default, i.e. 0, arithmetic mean is used for calculating optimal weights.
Otherwise, a vector of specific weights is used.}

\item{evgrid}{a vector of gridpoints used to evaluate quantile functions.}

\item{cl}{a float specifying the confidence level.}

\item{num.redraws}{an integer specifying the number of redraws used in the bootstrap approach.}
}
\value{
\code{DSC_main} returns a list containing the following components:
\item{\code{weight_t}}{a list of weights in each pre-treatment period.}
\item{\code{weights}}{a vector of optimal weights.}
\item{\code{bc_post}}{a list of post-treatment barycenters.}
\item{\code{CI_post}}{a list of post-treatment confidence intervals.}
}
\description{
Function for computing pre-treatment weights, optimal weights, post-treatment barycenters, post-treatment confidence intervals.
}
\examples{
#simulated data from independent normal distributions
#ex_normal() calls the simulated data
#detail can be found by ??ex_normal
DSC_main(c_df=ex_normal()$control, t_df=ex_normal()$target, T0=5, M=100, solver="SCS", ww="arithmetic", evgrid=seq(from=0, to=1, length.out=101), cl=0.99, num.redraws=500)
}
